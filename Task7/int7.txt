1️⃣ Why are dictionaries fast?

Dictionaries are fast because they use a hash table internally.
This allows average time complexity of O(1) for lookup, insertion, and deletion.

Why this matters:

Instead of searching every element (like a list), Python calculates a hash value for the key and directly jumps to the memory location.

Example:

student = {
    "name": "Swathi",
    "cgpa": 8.7
}

print(student["cgpa"])   # Very fast lookup


Internal idea (simple terms):

Key → hash function → memory address → value

No sequential scanning

Comparison:- 

| Operation | List | Dictionary |
| --------- | ---- | ---------- |
| Search    | O(n) | O(1)       |
| Insert    | O(n) | O(1)       |
| Delete    | O(n) | O(1)       |


one-liner:

Dictionaries trade memory for speed.



2️⃣ JSON vs Dictionary

A dictionary is a Python in-memory data structure, while JSON is a text-based data interchange format used for storage and communication.

Key Differences:

| Feature        | Dictionary    | JSON                 |
| -------------- | ------------- | -------------------- |
| Type           | Python object | Text format          |
| Language       | Python-only   | Language-independent |
| Stored in file | ❌             | ✅                    |
| Used for APIs  | ❌             | ✅                    |


Example:
Python Dictionary:
data = {"name": "Swathi", "year": 4}

JSON:
{
  "name": "Swathi",
  "year": 4
}

One-liner:

Dictionary is for processing; JSON is for sharing.



3️⃣ How to read JSON?

JSON is read in Python using the built-in json module and the json.load() method.

Example:
import json

with open("data.json", "r") as file:
    data = json.load(file)

print(data)

Important distinction:

json.load() → reads from file

json.loads() → reads from string

Example:
json_string = '{"name": "Swathi"}'
data = json.loads(json_string)

One-liner:

load for files, loads for strings.



4️⃣ What is a KeyError?

A KeyError occurs when we try to access a key that does not exist in a dictionary.

Example:
student = {"name": "Swathi"}

print(student["age"])   # ❌ KeyError

How to avoid it:
Using get():
print(student.get("age", "Not Found"))

Using in keyword:
if "age" in student:
    print(student["age"])

One-liner:

KeyError means the key is missing, not the dictionary.



5️⃣ Real-world use cases

Dictionaries and JSON are heavily used in real-world applications for structured data storage and fast lookups.

Common real-world use cases:
1. User Profiles
user = {
    "username": "swathi123",
    "email": "swathi@gmail.com"
}

2. API Responses (JSON)
{
  "status": "success",
  "data": {
    "id": 101,
    "name": "Swathi"
  }
}

3. Configuration Files
{
  "database": "mysql",
  "port": 3306
}

4. Caching Systems

Redis stores key–value pairs

Extremely fast retrieval

5. Machine Learning

Feature-value mappings

Model parameters

Metadata storage

One-liner:

Dictionaries power fast lookups; JSON powers data exchange.



⭐ Final Summary

Dictionaries are fast → Hash tables, O(1)

JSON vs Dict → Storage vs processing

Reading JSON → json.load()

KeyError → Accessing missing key

Real-world use → APIs, configs, caching, ML

